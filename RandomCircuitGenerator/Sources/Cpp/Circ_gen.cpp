#include "../Header/Header.h"
#include <ctime>
#include <time.h>


int circ_gen(int n, int l, int c, int pi, int po, int num_mutants, int num_mutations, 
			bool latch_in_C, bool latch_out_C, bool have_comb_loop, bool have_seq_loop,
			bool latch_in_L, bool latch_out_L)
{


	string library_path;
	string print_path;
	double returned_t; 
	string NLC = to_string(n) + "_" + to_string(l) + "_" + to_string(c);

	make_dir(n, l, c, num_mutants);

	string CWD = string(getcwd(NULL, 0));
	
	int loc = 0;
	while ((loc = CWD.find("\\", loc))> 0)
	{
		CWD.replace(loc, 1, "/"); //for Windows
	}

	
	string top_mdl = "TOP_" + NLC;
	
	vector<vector<triple>> mutations;
	mutations.resize(num_mutants);

	vector<string> mutants_log_paths;
	mutants_log_paths.resize(num_mutants, CWD + output_path + "Logs");//mutants and original one
	string orig_log_path = CWD + output_path + "Logs/orig_log.txt";

	string syr_path = CWD + output_path + "SYR/";
	string comp_dir = syr_path + "NLC_" + NLC + "/orig";
	string tcl_path = CWD + output_path + "TCL/";
	string tcl_name = "orig_script";

	vector <string>  Verilog_files;
	vector <string>  files_paths;
	string full_lib_path = CWD + Verilog_lib_path;
	int num_files = list_it(Verilog_files, files_paths, full_lib_path.c_str(), full_lib_path.size());
	
	ofstream orig_log;
	orig_log.open(orig_log_path, ios::out);
	if (orig_log.is_open())
	{
		orig_log << "** Log file of Original circuit, generated by NLC generator. **\n\n";
		orig_log << "Number of modules in each combinational region: " << c << "\n";
		orig_log << "Number of layers in pipeline: " << l << "\n";
		orig_log << "Number of disjoint regions: " << n << "\n";
		orig_log << "Specified number of primary inputs: " << pi << "\n";
		orig_log << "Specified number of primary outputs: " << pi << "\n";
		orig_log << "Path where output files are stored: " << tcl_path << "\n";
		orig_log << "Path of Verilog files used: " << full_lib_path << "\n";
		orig_log << "Number of Verilog files in library: " << num_files << "\n";
	}
	
	ofstream mut_log;
	for (int i = 0; i < num_mutants; i++)
	{
		mutations[i].resize(n*l, triple(0, 0, 0));

		mutants_log_paths[i] += "/m_" + to_string(i) + "_log.txt";
		
		mut_log.open(mutants_log_paths[i], ios::out);
		
		mut_log << "** Log file of mutant #" << i << " of circuit, generated by NLC generator. **\n\n";

		mut_log.close();
		
	}
	
	rand_init(0, n*l - 1); // mutation may happen in each of N*L combinational region

	for (int i = 0; i < num_mutants; i++)
	{
		for (int j = 0; j < num_mutations; j++)
		{
			int type = rand_mod(0, 3);

			int region = rand_c();

			if (type == 0)
			{
				mutations[i][region].inc_type1();// number of mutations of type add
			}
			else if (type == 1)
			{
				mutations[i][region].inc_type2();// number of mutations of type replace
			}
			else if (type == 2)
			{
				mutations[i][region].inc_type3();// number of mutations of type swap
			}
		}
	}
	
	
	rand_init(0, c - 1);

	script_start(tcl_path + "TOP_" + NLC + ".cmd");
	
	
	tcl_gen_part1(num_files, tcl_path, tcl_name, top_mdl, comp_dir);

	for (int i=0; i<num_mutants; i++)
	{
		tcl_name= "m_" + to_string(i)+ "_script";
		comp_dir = syr_path + "NLC_" + NLC + "/m_" + to_string(i);
		tcl_gen_part1(num_files, tcl_path, tcl_name, top_mdl, comp_dir);
	}
	
	
	 
	if (num_files > 0) // Verilog files library is not empty
	{	
		vector<Node> lib;
		vec_int in_which = init_lib(Verilog_files, files_paths, lib);
		int lib_size = Verilog_files.size();
	
		orig_log << "Number of Verilog modules in library (library size): " << lib_size << "\n";
		orig_log.close();
		
		int keep_po = po; 
		string V_output_path = CWD + output_path + "Verilog";
		for (int j=0; j<n; j++)
		{
			vector<string> sub_folders(num_mutants);
			for (int i = 0; i < l; i++)
			{

				layer_has_clk = false;
				layer_has_rst = false;
				layer_has_ce = false;
				
				string name = "Layer_" + to_string(j) + "_" + to_string(i);
				cout << name << endl;
				orig_log.open(orig_log_path, ios::app);
				orig_log << "\nN = " << j << ", L = " << i <<endl;
				orig_log.close();
				
				Graph g(c, pi, po, latch_in_C, latch_out_C, have_comb_loop, have_seq_loop);
				
				rand_init(0, c-1);
				
				g.select(lib);
				
				if(g.setIO(pi,  po, orig_log_path)==0)
					g.connect_inputs( orig_log_path);
				
			
				int new_po = po;
				for (int m = 0; m < num_mutants; m++)
				{
					Graph gprim = g;

					mut_log.open(mutants_log_paths[m], ios::app);

					mut_log << "\nN = " << j << ", L = " << i << endl;
					
					sub_folders[m]  = V_output_path + "/mutant_" + to_string(m)+
						"/N_" + to_string(j) + "/";

					
					if (mutations[m][i*n + j].get_type1() > 0)
					{
						gprim.mutate_add( mutations[m][i*n + j].get_type1(), mutants_log_paths[m]);
					}
						
					if (mutations[m][i*n + j].get_type2() > 0)
					{
						gprim.mutate_replace(mutations[m][i*n + j].get_type2(), mutants_log_paths[m]);
					}

					if (mutations[m][i*n + j].get_type3()> 0)
					{
						gprim.mutate_swap(mutations[m][i*n + j].get_type3(), mutants_log_paths[m]);
					}
					

					mut_log.close();
					new_po = gprim.dangle(po, true, true, mutants_log_paths[m]);
					mut_log.open(mutants_log_paths[m], ios::app);
					gprim.print('C', j, i, name, sub_folders[m], Verilog_files);

					tcl_name= "m_" + to_string(m)+ "_script";
					tcl_gen_part2(gprim, Verilog_files, in_which, j, i, tcl_path, tcl_name, m+1);//m+1 is vesion, 0 is original
					
					mut_log.close();

				}
				
				new_po = g.dangle(po, true, true, orig_log_path);
				orig_log.open(orig_log_path, ios::app);

				print_path = V_output_path + "/original/N_" + to_string(j) + "/";
				g.print('C', j, i, name, print_path, Verilog_files);

				tcl_name = "orig_script";
				tcl_gen_part2(g, Verilog_files, in_which, j, i, tcl_path, tcl_name, 0);// 0 is original one
				orig_log.close();
				
				//cal_net_degree(g, c);
				
				po = keep_po;
				
			}
			
			//print_net_degree();
			
			for (int m = 0; m < num_mutants; m++)
			{
				library_path = sub_folders[m];
				print_path = CWD + output_path + "Verilog/mutant_" +
					to_string (m)+ "/N_" + to_string(n) + "/";
				Graph mt_layer = Graph(l, pi, po, latch_in_L, latch_out_L, have_comb_loop, have_seq_loop);
				returned_t = mt_layer.make_layer(n, j, l,latch_in_L, latch_out_L, library_path, print_path, mutants_log_paths[m], m);
				
				po = keep_po;
				
			}
			
			/* original one */
			library_path =  V_output_path+ "/original/N_" + to_string(j) + "/";
			print_path = V_output_path + "/original/N_" + to_string(n)+ "/";
			Graph orig_layer = Graph(l, pi, po, latch_in_L, latch_out_L, have_comb_loop, have_seq_loop);
			returned_t = orig_layer.make_layer(n, j, l, latch_in_L, latch_out_L,
						library_path, print_path, orig_log_path, -1);
			
		}

		for (int m = 0; m < num_mutants; m++)
		{
			
			library_path = CWD + output_path + "Verilog/mutant_" + to_string(m) +
				"/N_" + to_string(n) + "/";
			print_path =  CWD + output_path + "Verilog/mutant_"+ to_string(m) + "/final/";
			
			returned_t= make_top(n, l, c, library_path, print_path, mutants_log_paths[m]);
			
			tcl_name= "m_" + to_string(m)+ "_script";
			tcl_gen_part3(n, l, c, tcl_path, tcl_name, m+1);
		}
		
		 library_path = CWD + output_path + "Verilog/original/" + "N_" + to_string(n) + "/";
		 print_path =  CWD + output_path + "Verilog/original/final/";
		
		returned_t= make_top(n, l, c, library_path, print_path, orig_log_path);
		
		tcl_name = "orig_script";
		tcl_gen_part3(n, l, c, tcl_path, tcl_name, 0);


		/* Clean temp directory */
		string tmp_path = string(getcwd(NULL, 0)) + "/" + insts_path;
		clean_it(tmp_path); //clean up destination folder
		

		return 0;
	}
	else
	{
		cerr << "Empty Library! Process failed.\n";
		return -1;
	}
}
